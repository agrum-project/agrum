/***********************************************************************
    * Copyright (c) 2013, Atos
    *
    * All rights reserved. This program and the accompanying materials
    * are made available under the terms of the Eclipse Public License v1.0
    * which accompanies this distribution, and is available at
    * http://www.eclipse.org/legal/epl-v10.html
    *
    * Contributors:
    *    Anthony Fernandes Pires (Atos/ONERA) - initial API and implementation
    **********************************************************************/

package org.eclipselabs.agrum.services.model.plugin.generator;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Date;
import org.antlr.runtime.RecognitionException;
import org.eclipse.cdt.core.dom.ast.IASTFunctionDefinition;
import org.eclipse.cdt.core.dom.ast.IASTNode;
import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
import org.eclipse.cdt.core.model.ILanguage;
import org.eclipse.cdt.core.parser.FileContent;
import org.eclipse.cdt.core.parser.IncludeFileContentProvider;
import org.eclipse.cdt.core.parser.NullLogService;
import org.eclipse.cdt.core.parser.ScannerInfo;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.Path;
import org.eclipse.uml2.uml.StateMachine;
import org.eclipselabs.agrum.elements.acsl.basics.Behavior;
import org.eclipselabs.agrum.elements.acsl.basics.FunctionContract;
import org.eclipselabs.agrum.elements.acsl.basics.RequiresClause;
import org.eclipselabs.agrum.services.generator.exceptions.FindTransitionFunctionException;
import org.eclipselabs.agrum.services.generator.exceptions.ModelConstructionException;
import org.eclipselabs.agrum.services.generator.exceptions.OCLTranslationException;
import org.eclipselabs.agrum.services.model.plugin.parser.ModelParser;


/**
 * The class <code>Generator</code> groups the methods for the generation of ACSL annotations derived from a state machine into a C file.
 * @version 0.1.0
 * @author Anthony Fernandes Pires (Atos/ONERA)
 */
public class Generator {
	
	/**
	 * The path to the input source C file.
	 */
	private Path filePath;
	
	/**
	 * The path to the generated annotated C file.
	 */
	private Path generatedFilePath;
	
	/**
	 * The input state machine
	 */
	private StateMachine stateMachine;
	
	/**
	 * The name of the generator
	 */
	private final String name = "AGrUM";
	
	/**
	 * The version of the generator
	 */
	private final String version = "V0.1.0";

	/**
	 * Constructor. The path for the generated file is the same as the input c file.
	 * @param sm_ - the state machine in input
	 * @param filePath_ - the path to the C file to annotate
	 */
	public Generator( StateMachine sm_, String filePath_){
		stateMachine = sm_;
		filePath = new Path(filePath_);
		generatedFilePath = new Path(filePath.removeFileExtension().toString()+"_annotated.c");
	}
	
	/**
	 * Constructor
	 * @param sm_ - the state machine in input
	 * @param filePath_ - the path to the C file to annotate
	 * @param generatedFilePath_ - the path to generate the annotated C file
	 */
	public Generator(StateMachine sm_, String filePath_, String generatedFilePath_){
		stateMachine = sm_;
		filePath = new Path(filePath_);
		generatedFilePath = new Path(generatedFilePath_);
	}

	/**
	 * To load the C file in an ast
	 * @return the ast of the C file
	 * @throws CoreException
	 * @throws FindTransitionFunctionException
	 */
	public IASTTranslationUnit loadFile() throws CoreException,FindTransitionFunctionException{

		IASTTranslationUnit atu=null;
			atu = org.eclipse.cdt.core.dom.ast.gnu.c.GCCLanguage.getDefault().getASTTranslationUnit(FileContent.createForExternalFileLocation(filePath.toString()), new ScannerInfo(), IncludeFileContentProvider.getEmptyFilesProvider(), null, ILanguage.OPTION_IS_SOURCE_UNIT, new NullLogService());
		return atu;
	}

	/**
	 * The method to generate ACSL contract from a state machine.
	 * @param stateVariableName - the name of the variable representing the current state in the function
	 * @throws IOException
	 * @throws FindTransitionFunctionException
	 * @throws ModelConstructionException
	 * @throws RecognitionException
	 * @throws OCLTranslationException
	 * @throws CoreException
	 */
	public void generateACSL(String stateVariableName) throws IOException, FindTransitionFunctionException, ModelConstructionException, RecognitionException, OCLTranslationException, CoreException{

		Date date = new Date();
		String  generatorCredits = "/**************************************" +"\n" + " *File generated by " + name + " " + version + "*\n" + " *"+date.toString()+"        *\n **************************************/\n";
		PrintWriter fichier = null;
		int TTickFunctionOffset=0;
		int TCFunctionOffset=0;

		//parse the specified statemachine and get its function contract for the transition function
		FunctionContract tick_ctr = new FunctionContract(new ArrayList<RequiresClause>(), new ArrayList<Behavior>());
		FunctionContract completion_ctr = new FunctionContract(new ArrayList<RequiresClause>(), new ArrayList<Behavior>());
				
		ModelParser.checkStateMachineModelling(stateMachine);
		
		tick_ctr = ModelParser.parseStateMachineForTick(stateVariableName, stateMachine);
		completion_ctr = ModelParser.parseStateMachineForCompletion(stateVariableName, stateMachine);

		//parse the C file to annotate
		IASTTranslationUnit atu = loadFile();
		if (!findFunction("T_tick", atu)) throw new FindTransitionFunctionException("T_tick");
		if (!findFunction("T_c", atu)) throw new FindTransitionFunctionException("T_c");
		File targetFile = new File(generatedFilePath.toString());
		targetFile.createNewFile();
		//Create the writer to write the annotated file

		fichier =  new PrintWriter(new BufferedWriter(new FileWriter( generatedFilePath.toString())));

		String code = atu.getRawSignature();

		//write all the declarations of the original C file
		IASTNode[] astDeclarations = atu.getDeclarations();
		
		//For the T_tick function
		for (int i=0;i<astDeclarations.length;i++){

			//if the declaration is a function definition and its name corresponds to the name of the statemachine, following the code pattern for the transition function(_T), we add the function contract before
			if (astDeclarations[i] instanceof IASTFunctionDefinition){
				if (((IASTFunctionDefinition)astDeclarations[i]).getDeclarator().getName().toString().contentEquals("T_tick")){
					TTickFunctionOffset=astDeclarations[i].getFileLocation().getNodeOffset();
				} else if (((IASTFunctionDefinition)astDeclarations[i]).getDeclarator().getName().toString().contentEquals("T_c")){
					TCFunctionOffset=astDeclarations[i].getFileLocation().getNodeOffset();
				}
			}
		}
		
		String codeToWrite="";
		//Addition of the annotation in the code, according to the place of the transition functions for the tick event and the completion event
		if (TTickFunctionOffset<TCFunctionOffset){
			String codeBeforeTTick = code.substring(0, TTickFunctionOffset);
			String codeAfterTTick = code.substring(TTickFunctionOffset);
			String codeBeforeTC = codeAfterTTick.substring(0, (TCFunctionOffset-TTickFunctionOffset));
			String codeAfterTC = codeAfterTTick.substring((TCFunctionOffset-TTickFunctionOffset));			
			codeToWrite = generatorCredits+"\n"+codeBeforeTTick+tick_ctr+ "\n"+ codeBeforeTC+ completion_ctr+"\n"+codeAfterTC;
		} else {
			String codeBeforeTC = code.substring(0, TCFunctionOffset);
			String codeAfterTC = code.substring(TCFunctionOffset);
			String codeBeforeTTick = codeAfterTC.substring(0, (TTickFunctionOffset-TCFunctionOffset));
			String codeAfterTTick = codeAfterTC.substring((TTickFunctionOffset-TCFunctionOffset));			
			codeToWrite = generatorCredits+"\n"+codeBeforeTC+completion_ctr+ "\n"+ codeBeforeTTick+ tick_ctr+"\n"+codeAfterTTick;
		}
		
		
		fichier.print(codeToWrite);
		fichier.close();
	}
	
	/**
	 * Find a specific function depending on its name
	 * @param transitionFunctionName - the name of the function
	 * @param atu - the ast of the given C source code
	 * @return a boolean value if a function with the corresponding name exists in the code.
	 */
	public boolean findFunction(String transitionFunctionName, IASTTranslationUnit atu){
		boolean result=false;
		IASTNode[] astDeclarations = atu.getDeclarations();
		for (int i=0;i<astDeclarations.length;i++){

			//if the declaration is a function definition and its name corresponds to the name of the function, return true
			if (astDeclarations[i] instanceof IASTFunctionDefinition){
				if (((IASTFunctionDefinition)astDeclarations[i]).getDeclarator().getName().toString().contentEquals(transitionFunctionName)){
					result=true;
				}
			}
		}
		return result;
	}
	

}
